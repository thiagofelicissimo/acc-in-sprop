<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Acc in SProp</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="doc/github-pandoc.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Acc in SProp</h1>
</header>
<h1
id="formalization-for-the-paper-definitional-proof-irrelevance-made-accessible">Formalization
for the paper â€œDefinitional Proof Irrelevance Made Accessibleâ€</h1>
<p>This repository contains the formalization of most proofs given in
the paper â€œDefinitional Proof Irrelevance Made Accessibleâ€.</p>
<h2 id="building">Building</h2>
<p>You need the Rocq prover 9.0 and Autosubst 2 OCaml (needs ocaml&lt;5,
recommended 4.14.2). You can install them using</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">opam</span> repo add rocq-released https://rocq-prover.org/opam/released</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ex">opam</span> install <span class="at">--deps-only</span> .</span></code></pre></div>
<p>Then to verify the proof, just use <code>make</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">make</span> autosubst</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="fu">make</span></span></code></pre></div>
<h2 id="overview">Overview</h2>
<h3 id="syntax">Syntax</h3>
<p>We specify the common syntax for the theories <span
class="math inline">ğ’¯<sub>=</sub></span> and <span
class="math inline">ğ’¯<sub>â‰¡</sub></span> in <a
href="theories/autosubst/AST.sig">AST.sig</a>, which is used by
Autosubst to automatically generate the syntax and notions of renaming
and substitutions, along with their respective laws. The <a
href="theories/autosubst/">autosubst</a> directory also contains some
custom non-automatically generated files, like <a
href="theories/autosubst/RAsimpl.v">RAsimpl.v</a> which defines a faster
substitution simplification tactic, and <a
href="theories/autosubst/SubstNotations.v">SubstNotations.v</a> which
specifies some notations.</p>
<h3 id="preliminary-files">Preliminary files</h3>
<ul>
<li><p><a href="theories/BasicAST.v">BasicAST.v</a>: Definition of
universe levels and of its basic operations</p></li>
<li><p><a href="theories/Util.v">Util.v</a>: General tactics, lemmas and
notations.</p></li>
<li><p><a href="theories/Typing.v">Typing.v</a>: Typing rules of <span
class="math inline">ğ’¯<sub>=</sub></span> and <span
class="math inline">ğ’¯<sub>â‰¡</sub></span>. We use a single mutual
inductive family parametrized by a mode <code>M</code>, which can be
either <code>mdef</code> for the definitional theory (<span
class="math inline">ğ’¯<sub>â‰¡</sub></span>), or <code>mprop</code> for the
propositional theory (<span class="math inline">ğ’¯<sub>=</sub></span>).
The rule for <code>accelcomp</code> then requires a proof that
<code>M = mdef</code>. We also assume a
<code>Parameter assm_sig : list term</code> for representing the
signature of axioms <span class="math inline"><em>Î£</em></span>, and
suppose that the type of an axiom is well typed in <span
class="math inline">ğ’¯<sub>=</sub></span> if it is well-typed in <span
class="math inline">ğ’¯<sub>â‰¡</sub></span>. This assumption is of course
validated by the common axioms one uses in practice, such as
propositional extensionality, functional extensionality, excluded middle
and various forms of choice.</p></li>
<li><p><a href="theories/BasicMetaTheory.v">BasicMetaTheory.v</a>: Basic
metatheoretic properties of the two systems, including stability under
weakening and substitution, validity, type inversion and some more
economical versions of the typing and conversion rules.</p></li>
<li><p><a href="theories/AccConstructions.v">AccConstructions.v</a>:
Working internally to <span class="math inline">ğ’¯<sub>â‰¡</sub></span> or
<span class="math inline">ğ’¯<sub>=</sub></span>, we show that the usual
elimination principle for accessibility can be derived from the weaker
one we have in the definition of the theories.</p></li>
</ul>
<h3 id="canonicity-of-mathcalt_equiv">Canonicity of <span
class="math inline">ğ’¯<sub>â‰¡</sub></span></h3>
<ul>
<li><p><a href="theories/Reduction.v">Reduction.v</a>: Definition of a
typed and deterministic weak-head reduction relation for <span
class="math inline">ğ’¯<sub>â‰¡</sub></span>, needed for defining the
logical relation. We also prove some of its basic properties.</p></li>
<li><p><a href="theories/LRDef.v">LRDef.v</a>: Definition of the logical
relation for proving canonicity of <span
class="math inline">ğ’¯<sub>â‰¡</sub></span>. We use a module to hide the
definition of the logical relation, which has some technical
aspects.</p></li>
<li><p><a href="theories/LRBasicProps.v">LRBasicProps.v</a>: Basic
properties of the logical relation, including escape, closure under
reduction and anti-reduction, stability under annotation exchange,
inversion, irrelevance, symmetry and transitivity. We also extend the
logical relation to substitutions, define validity, and prove that they
both also satisfy symmetry and transitivity.</p></li>
<li><p><a href="theories/FundamentalAux.v">FundamentalAux.v</a>:
Auxiliary lemmas for proving the fundamental theorem of the logical
relation.</p></li>
<li><p><a href="theories/FundamentalPi.v">FundamentalPi.v</a>, <a
href="theories/FundamentalNat.v">FundamentalNat.v</a>, <a
href="theories/FundamentalAcc.v">FundamentalAcc.v</a>, <a
href="theories/FundamentalCast.v">FundamentalCast.v</a>: Cases of proof
of fundamental theorem for function types, natural numbers,
accessibility and observational equality. As explained in the paper, the
proofs for accessibility and observational equality rely on some
assumptions which are provable in set theory by constructing the
standard model of <span
class="math inline">ğ’¯<sub>â‰¡</sub></span>.</p></li>
<li><p><a href="theories/Fundamental.v">Fundamental.v</a>: Proof of the
fundamental theorem of the logical relation. As a corollary, we derive
canonicity for <span class="math inline">ğ’¯<sub>â‰¡</sub></span>.</p></li>
<li><p><a href="theories/CompCanonicity.v">CompCanonicity.v</a>: Proof
of effective canonicity for <span
class="math inline">ğ’¯<sub>â‰¡</sub></span>, in which the natural number is
computed through untyped reduction of the erasure of the term.</p></li>
</ul>
<h3 id="conservativity-of-mathcalt_equiv-over-mathcalt_">Conservativity
of <span class="math inline">ğ’¯<sub>â‰¡</sub></span> over <span
class="math inline">ğ’¯<sub>=</sub></span></h3>
<ul>
<li><p><a href="theories/HEq.v">HEq.v</a>: Definition of heterogeneous
equality in <span class="math inline">ğ’¯<sub>=</sub></span> and proofs of
its important properties. To make the proofs practically feasible, here
we work internally to the object theory: we postulate sufficiently many
primitives to turn Rocq into a proof assistant for <span
class="math inline">ğ’¯<sub>=</sub></span>.</p></li>
<li><p><a href="theories/CHEqProps.v">CHEqProps.v</a>: Postulates of the
external versions of the terms and proofs constructed internally in the
file <a href="theories/HEq.v">HEq.v</a>.</p></li>
<li><p><a href="theories/CDecoration.v">CDecoration.v</a>: Definition of
the decoration relation and proof of the fundamental lemma of the
translation, stating that related well-typed terms in <span
class="math inline">ğ’¯<sub>=</sub></span> are heterogeneously
equal.</p></li>
<li><p><a href="theories/CTranslation.v">CTranslation.v</a>: Proof of
the decorating translation from <span
class="math inline">ğ’¯<sub>â‰¡</sub></span> to <span
class="math inline">ğ’¯<sub>=</sub></span>. As a corollary, we deduce the
conservativity of <span class="math inline">ğ’¯<sub>â‰¡</sub></span> over
<span class="math inline">ğ’¯<sub>=</sub></span>. Combined with the result
of <a href="theories/CompCanonicity.v">CompCanonicity.v</a>, we derive
propositional canonicity for <span
class="math inline">ğ’¯<sub>=</sub></span>.</p></li>
</ul>
<h3 id="set-theoretic-model">Set theoretic model</h3>
<p>Higher-order IZF_R with omega universes:</p>
<ul>
<li><p><a href="theories/SetModel/ZF_axioms.v">ZF_axioms.v</a>:
axioms</p></li>
<li><p><a href="theories/SetModel/ZF_library.v">ZF_library.v</a>:
unions, cartesian products, function sets, dependent function
sets</p></li>
<li><p><a href="theories/SetModel/ZF_nat.v">ZF_nat.v</a>: set-theoretic
natural numbers with large eliminator</p></li>
<li><p><a href="theories/SetModel/ZF_acc.v">ZF_acc.v</a>: set-theoretic
accessibility predicate with large eliminator</p></li>
</ul>
<p>Higher-order model of OTT :</p>
<ul>
<li><p><a href="theories/SetModel/HO.v">HO.v</a>: preliminaries</p></li>
<li><p><a href="theories/SetModel/HO_univ.v">HO_univ.v</a>:
universes</p></li>
<li><p><a href="theories/SetModel/HO_prop.v">HO_prop.v</a>: type of
propositions with definitional proof irrelevance</p></li>
<li><p><a href="theories/SetModel/HO_pi.v">HO_pi.v</a>: proof-relevant
dependent products (with beta/eta)</p></li>
<li><p><a href="theories/SetModel/HO_sigma.v">HO_sigma.v</a>: dependent
sums (with beta/eta)</p></li>
<li><p><a href="theories/SetModel/HO_nat.v">HO_nat.v</a>: natural
numbers with large eliminator (with beta)</p></li>
<li><p><a href="theories/SetModel/HO_box.v">HO_box.v</a>: boxed
proposiitons (with eta)</p></li>
<li><p><a href="theories/SetModel/HO_false.v">HO_false.v</a>: false
proposition (not inhabited in the empty context)</p></li>
<li><p><a href="theories/SetModel/HO_forall.v">HO_forall.v</a>:
proof-irrelevant dependent products</p></li>
<li><p><a href="theories/SetModel/HO_obseq.v">HO_obseq.v</a>:
observational equality, cast, cast-on-refl, funext, propext, injectivity
of pi, cast-on-functions, no confusion (nat â‰  pi)</p></li>
<li><p><a href="theories/SetModel/HO_acc.v">HO_acc.v</a>: accessibility
predicate and its eliminator (with beta)</p></li>
</ul>
</body>
</html>
